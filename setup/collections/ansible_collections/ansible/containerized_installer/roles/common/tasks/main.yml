---
- name: Ensure remote user is non root
  ansible.builtin.assert:
    that:
      - ansible_user_uid != 0
    fail_msg: 'the remote user should be a non root user'

- name: Get service facts
  ansible.builtin.service_facts:
  become: true

- name: Configure sub UID/GIDs
  ansible.builtin.include_tasks: subids.yml

- name: Run ostree tasks
  ansible.builtin.include_tasks: ostree.yml

- name: Ostree-based OS setup
  when: ostree | bool
  block:
    - name: Get package Facts
      ansible.builtin.package_facts:
      become: true

    - name: Ensure container tools packages are present
      ansible.builtin.assert:
        that:
          - 'item in ansible_facts["packages"]'
        fail_msg: 'On OSTree based system, the following package needs to be present: {{ item }}'
      loop: '{{ podman_packages }}'

    - name: Ensure python3-cryptography and python3-psycopg2 python packages are present
      ansible.builtin.assert:
        that:
          - '"python3-cryptography" in ansible_facts["packages"]'
          - '"python3-psycopg2" in ansible_facts["packages"]'
        fail_msg: 'On OSTree based system, the following packages need to be present: python3-cryptography and python3-psycopg2'
      when: >
        inventory_hostname in groups.get('automationcontroller', []) or
        inventory_hostname in groups.get('automationeda', []) or
        inventory_hostname in groups.get('automationhub', [])

    - name: Ensure python3-cryptography python package is present
      ansible.builtin.assert:
        that:
          - '"python3-cryptography" in ansible_facts["packages"]'
        fail_msg: 'On OSTree based system, the python3-cryptography package needs to be present'
      when: >
        inventory_hostname in groups.get('database', []) or
        inventory_hostname in groups.get('execution_nodes', [])

    - name: Ensure python3-firewall package is present
      ansible.builtin.assert:
        that:
          - '"python3-firewall" in ansible_facts["packages"]'
        fail_msg: 'On OSTree based system, the following package needs to be present: python3-firewall'
      when:
        - ansible_facts.services.get('firewalld.service', {}) | length
        - ansible_facts.services['firewalld.service']['status'] == 'enabled'

- name: Install container tools
  ansible.builtin.package:
    name: '{{ podman_packages }}'
  become: true
  when: not ostree | bool

- name: Create the containers config directory
  ansible.builtin.file:
    path: '{{ ansible_user_dir }}/.config/containers'
    state: directory
    mode: '0755'

- name: Configure podman runtime with crun
  ansible.builtin.template:
    src: containers.conf.j2
    dest: '{{ ansible_user_dir }}/.config/containers/containers.conf'
    mode: '0644'

- name: Configure podman execution plane
  ansible.builtin.include_tasks: executionplane.yml
  when: >
    inventory_hostname in groups.get('automationcontroller', []) or
    inventory_hostname in groups.get('automationeda', []) or
    inventory_hostname in groups.get('execution_nodes', [])

- name: Enable lingering for ansible_user
  ansible.builtin.command: loginctl enable-linger {{ ansible_user_id }}
  args:
    creates: '/var/lib/systemd/linger/{{ ansible_user_id }}'

- name: Include registry tasks
  ansible.builtin.include_tasks: registry.yml
  when:
    - not bundle_install | bool
    - registry_auth | bool

- name: Include container image tasks
  ansible.builtin.include_tasks: images.yml

- name: Offline container images workflow
  when: bundle_install | bool
  block:
    - name: Install compress package
      ansible.builtin.package:
        name: '{{ container_compress }}'
      become: true
      when: not ostree | bool

    - name: Create temporary directory for container tarballs
      ansible.builtin.tempfile:
        path: '{{ images_tmp_dir | default(omit) }}'
        state: directory
        suffix: images
      register: images_tmp

    - name: Copy bundled container images
      block:
        - name: Copy bundled container images
          ansible.posix.synchronize:
            src: '{{ bundle_dir }}/images/'
            dest: '{{ images_tmp.path }}'
      rescue:
        - name: Copy bundled container images (legacy)
          ansible.builtin.copy:
            src: '{{ bundle_dir }}/images/'
            dest: '{{ images_tmp.path }}'
            mode: '0644'

      # PostgreSQL image bundled with AAPReporter installer should not replace
      # the same image bundled with AAP installer.
      # Check if AAP installer already loaded the images.
      # Downside: AAPReporter installer will never refresh PostgreSQL image.
      # In addition, bundled AAPReporter installer includes only images for postgres and reporter.
      # Do not try to load other images.
    - name: TEMP List existing container images
      containers.podman.podman_image_info:
        name: "{{ _postgresql_image }}"
      register: _existing_postgresql_image_result

    - name: Uncompress bundled container images
      ansible.builtin.command: '{{ container_compress }} -d {{ images_tmp.path }}/{{ image }}.tar.gz'
      args:
        creates: '{{ images_tmp.path }}/{{ image }}.tar'
      loop: '{{ _images | union((__de_images | default([])) | union(__ee_images | default([]))) | unique }}'
      vars:
        image: '{{ (item | basename).split(":")[0] }}'
      when: |
        item == _reporter_image_be
        or (item == _postgresql_image and _existing_postgresql_image_result.images | length == 0)

    - name: Load the controlplane container images
      containers.podman.podman_load:
        path: '{{ images_tmp.path }}/{{ image }}.tar'
      loop: '{{ _images | unique }}'
      vars:
        image: '{{ (item | basename).split(":")[0] }}'
      when:
        item == _reporter_image_be
        or (item == _postgresql_image and _existing_postgresql_image_result.images | length == 0)

    - name: Load the executionplane container images
      containers.podman.podman_load:
        path: '{{ images_tmp.path }}/{{ image }}.tar'
      environment:
        CONTAINERS_STORAGE_CONF: '{{ ansible_user_dir }}/aap/containers/storage.conf'
      loop: '{{ (__de_images | default([])) | union(__ee_images | default([])) | unique }}'
      vars:
        image: '{{ (item | basename).split(":")[0] }}'
      when: false  # not for reporter-only deploy

    - name: Set io.containers.autoupdate=local label
      ansible.builtin.set_fact:
        _autoupdate_label:
          io.containers.autoupdate: local
  always:
    - name: Remove temporary directory
      ansible.builtin.file:
        path: "{{ images_tmp.path }}"
        state: absent
      when: images_tmp.path is defined

- name: Online container images workflow
  when: not bundle_install | bool
  block:
    - name: Pull the controlplane container images
      containers.podman.podman_image:
        name: '{{ item }}'
        pull: true
        force: '{{ container_image_update }}'
        validate_certs: '{{ registry_tls_verify }}'
      loop: '{{ _images | unique }}'
      environment:
        HTTP_PROXY: "{{ http_proxy | default('') }}"
        HTTPS_PROXY: "{{ https_proxy | default('') }}"
        NO_PROXY: "{{ no_proxy | default('') }}"

    - name: Pull the executionplane container images
      containers.podman.podman_image:
        name: '{{ item }}'
        pull: true
        force: '{{ container_image_update }}'
        validate_certs: '{{ registry_tls_verify }}'
      environment:
        CONTAINERS_STORAGE_CONF: '{{ ansible_user_dir }}/aap/containers/storage.conf'
        HTTP_PROXY: "{{ http_proxy | default('') }}"
        HTTPS_PROXY: "{{ https_proxy | default('') }}"
        NO_PROXY: "{{ no_proxy | default('') }}"
      loop: '{{ (__de_images | default([])) | union(__ee_images | default([])) | unique }}'

    - name: Set io.containers.autoupdate=registry label
      ansible.builtin.set_fact:
        _autoupdate_label:
          io.containers.autoupdate: registry
          io.containers.autoupdate.authfile: '{{ ansible_user_dir }}/.config/containers/auth.json'

- name: Configure firewalld
  ansible.builtin.include_tasks: firewalld.yml

- name: Configure TLS CA
  ansible.builtin.include_tasks: tls.yml
...
